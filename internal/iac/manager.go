// Package iac manages infrastructure provisioning using Terraform.
package iac

import (
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"time"
)

// ProvisionRequest represents an infrastructure provisioning request.
type ProvisionRequest struct {
	Provider string            `json:"provider"`
	Arch     string            `json:"arch"`
	Spec     map[string]string `json:"spec"`
}

// Instance represents a provisioned instance.
type Instance struct {
	ID           string            `json:"id"`
	Provider     string            `json:"provider"`
	Status       string            `json:"status"`
	IPAddress    string            `json:"ip_address"`
	Arch         string            `json:"arch"`
	Metadata     map[string]string `json:"metadata"`
	TerraformDir string            `json:"-"`
}

// Manager manages infrastructure provisioning using Terraform.
type Manager struct {
	instances    map[string]*Instance
	mu           sync.RWMutex
	workspaceDir string
}

// NewManager creates a new IaC manager.
func NewManager() *Manager {
	workspaceDir := filepath.Join(os.TempDir(), "portage-terraform")
	_ = os.MkdirAll(workspaceDir, 0750)

	return &Manager{
		instances:    make(map[string]*Instance),
		workspaceDir: workspaceDir,
	}
}

// Provision provisions a new instance using Terraform.
func (m *Manager) Provision(req *ProvisionRequest) (*Instance, error) {
	instanceID := fmt.Sprintf("%s-%d", req.Provider, time.Now().UnixNano())
	terraformDir := filepath.Join(m.workspaceDir, instanceID)

	if err := os.MkdirAll(terraformDir, 0750); err != nil {
		return nil, fmt.Errorf("failed to create terraform directory: %w", err)
	}

	// Generate Terraform configuration
	tfConfig := generateTerraformConfig(req)
	tfFile := filepath.Join(terraformDir, "main.tf")
	if err := os.WriteFile(tfFile, []byte(tfConfig), 0600); err != nil {
		return nil, fmt.Errorf("failed to write terraform config: %w", err)
	}

	// Run Terraform commands
	fmt.Printf("Provisioning %s instance with Terraform...\n", req.Provider)

	// In production, this would run: terraform init, plan, apply
	// For now, we simulate the instance creation

	instance := &Instance{
		ID:           instanceID,
		Provider:     req.Provider,
		Status:       "running",
		IPAddress:    fmt.Sprintf("192.168.1.%d", time.Now().Unix()%250+1),
		Arch:         req.Arch,
		Metadata:     req.Spec,
		TerraformDir: terraformDir,
	}

	m.mu.Lock()
	m.instances[instanceID] = instance
	m.mu.Unlock()

	return instance, nil
}

// Terminate terminates an instance using Terraform destroy.
func (m *Manager) Terminate(instanceID string) error {
	m.mu.RLock()
	instance, exists := m.instances[instanceID]
	m.mu.RUnlock()

	if !exists {
		return fmt.Errorf("instance not found: %s", instanceID)
	}

	fmt.Printf("Terminating instance %s with Terraform...\n", instanceID)

	// In production, this would run: terraform destroy -auto-approve
	_ = os.RemoveAll(instance.TerraformDir) //nolint:errcheck // Cleanup //nolint:errcheck // Cleanup

	m.mu.Lock()
	delete(m.instances, instanceID)
	m.mu.Unlock()

	return nil
}

// GetInstance returns an instance by ID.
func (m *Manager) GetInstance(instanceID string) (*Instance, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()

	instance, exists := m.instances[instanceID]
	if !exists {
		return nil, fmt.Errorf("instance not found: %s", instanceID)
	}

	return instance, nil
}

// ListInstances returns all active instances.
func (m *Manager) ListInstances() []*Instance {
	m.mu.RLock()
	defer m.mu.RUnlock()

	instances := make([]*Instance, 0, len(m.instances))
	for _, instance := range m.instances {
		instances = append(instances, instance)
	}

	return instances
}

// generateTerraformConfig generates Terraform configuration based on provider.
func generateTerraformConfig(req *ProvisionRequest) string {
	region := getOrDefault(req.Spec, "region", "us-central1")

	switch req.Provider {
	case "aliyun":
		return fmt.Sprintf(`
# Terraform configuration for Aliyun (Alibaba Cloud)
# Generated by Portage Engine
terraform {
  required_providers {
    alicloud = {
      source  = "aliyun/alicloud"
      version = "~> 1.0"
    }
  }
}

provider "alicloud" {
  region = "%s"
}

resource "alicloud_instance" "portage_builder" {
  instance_name = "portage-builder-%s"
  instance_type = "ecs.c5.large"
  image_id      = "gentoo-latest"

  tags = {
    Purpose = "PortageBuild"
    Arch    = "%s"
  }
}

output "ip_address" {
  value = alicloud_instance.portage_builder.public_ip
}
`, region, req.Arch, req.Arch)

	case "gcp":
		return fmt.Sprintf(`
# Terraform configuration for Google Cloud Platform
# Generated by Portage Engine
terraform {
  required_providers {
    google = {
      source  = "hashicorp/google"
      version = "~> 4.0"
    }
  }
}

provider "google" {
  project = "portage-engine"
  region  = "%s"
}

resource "google_compute_instance" "portage_builder" {
  name         = "portage-builder-%s"
  machine_type = "n1-standard-4"
  zone         = "%s-a"

  boot_disk {
    initialize_params {
      image = "gentoo-cloud/gentoo-latest"
      size  = 50
    }
  }

  network_interface {
    network = "default"
    access_config {}
  }

  tags = ["portage-builder"]
}

output "ip_address" {
  value = google_compute_instance.portage_builder.network_interface[0].access_config[0].nat_ip
}
`, region, req.Arch, region)

	case "aws":
		return fmt.Sprintf(`
# Terraform configuration for Amazon Web Services
# Generated by Portage Engine
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 4.0"
    }
  }
}

provider "aws" {
  region = "%s"
}

resource "aws_instance" "portage_builder" {
  ami           = "ami-gentoo-latest"
  instance_type = "t3.large"

  tags = {
    Name    = "portage-builder-%s"
    Purpose = "PortageBuild"
    Arch    = "%s"
  }

  root_block_device {
    volume_size = 50
    volume_type = "gp3"
  }
}

output "ip_address" {
  value = aws_instance.portage_builder.public_ip
}
`, region, req.Arch, req.Arch)

	default:
		return ""
	}
}

func getOrDefault(m map[string]string, key, defaultValue string) string {
	if val, ok := m[key]; ok {
		return val
	}
	return defaultValue
}
